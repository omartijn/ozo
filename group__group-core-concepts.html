<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OZO 「お象」: Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OZO 「お象」
   </div>
   <div id="projectbrief">Boost.Asio and libpq based asynchronous PostgreSQL unofficial header-only C++17 client library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-core-concepts.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Types</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Concepts<div class="ingroups"><a class="el" href="group__group-core.html">Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Library-wide concepts emulation mechanism. </p>
<p>We decide to use Concept-style meta programming to make easy to extend, adapt and test the library. So here is our own reinvented wheel of C++ Concepts built on template constants and std::enable_if. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Types</h2></td></tr>
<tr class="memitem:gaec336e235cdaabead728b12ecb63b38a"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename Type  = void&gt; </td></tr>
<tr class="memitem:gaec336e235cdaabead728b12ecb63b38a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#gaec336e235cdaabead728b12ecb63b38a">ozo::Require</a> = Type</td></tr>
<tr class="memdesc:gaec336e235cdaabead728b12ecb63b38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept requirement emulation.  <a href="group__group-core-concepts.html#gaec336e235cdaabead728b12ecb63b38a">More...</a><br /></td></tr>
<tr class="separator:gaec336e235cdaabead728b12ecb63b38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae0a9bc14ebe454c9d0b8f3055839d675"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae0a9bc14ebe454c9d0b8f3055839d675"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#gae0a9bc14ebe454c9d0b8f3055839d675">ozo::OperatorNot</a></td></tr>
<tr class="memdesc:gae0a9bc14ebe454c9d0b8f3055839d675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator Not concept.  <a href="group__group-core-concepts.html#gae0a9bc14ebe454c9d0b8f3055839d675">More...</a><br /></td></tr>
<tr class="separator:gae0a9bc14ebe454c9d0b8f3055839d675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3750f4893911580a5546d11bd5a9ca32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3750f4893911580a5546d11bd5a9ca32"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga3750f4893911580a5546d11bd5a9ca32">ozo::OutputIterator</a></td></tr>
<tr class="memdesc:ga3750f4893911580a5546d11bd5a9ca32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output Iterator concept.  <a href="group__group-core-concepts.html#ga3750f4893911580a5546d11bd5a9ca32">More...</a><br /></td></tr>
<tr class="separator:ga3750f4893911580a5546d11bd5a9ca32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762b9c7d7a45486c590d33ddb1330e9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga762b9c7d7a45486c590d33ddb1330e9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga762b9c7d7a45486c590d33ddb1330e9e">ozo::ForwardIterator</a></td></tr>
<tr class="memdesc:ga762b9c7d7a45486c590d33ddb1330e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward Iterator concept.  <a href="group__group-core-concepts.html#ga762b9c7d7a45486c590d33ddb1330e9e">More...</a><br /></td></tr>
<tr class="separator:ga762b9c7d7a45486c590d33ddb1330e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf513c2ac32e89e730a1019c94ec8fb19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf513c2ac32e89e730a1019c94ec8fb19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#gaf513c2ac32e89e730a1019c94ec8fb19">ozo::Iterable</a></td></tr>
<tr class="memdesc:gaf513c2ac32e89e730a1019c94ec8fb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterable concept.  <a href="group__group-core-concepts.html#gaf513c2ac32e89e730a1019c94ec8fb19">More...</a><br /></td></tr>
<tr class="separator:gaf513c2ac32e89e730a1019c94ec8fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bca84123276a5399ea63f2e249bd04d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4bca84123276a5399ea63f2e249bd04d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga4bca84123276a5399ea63f2e249bd04d">ozo::InsertIterator</a></td></tr>
<tr class="memdesc:ga4bca84123276a5399ea63f2e249bd04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert Iterator concept.  <a href="group__group-core-concepts.html#ga4bca84123276a5399ea63f2e249bd04d">More...</a><br /></td></tr>
<tr class="separator:ga4bca84123276a5399ea63f2e249bd04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8e06ab14ae860922eac58c1af30916"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8d8e06ab14ae860922eac58c1af30916"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga8d8e06ab14ae860922eac58c1af30916">ozo::FusionSequence</a></td></tr>
<tr class="memdesc:ga8d8e06ab14ae860922eac58c1af30916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost.Fusion Sequence concept.  <a href="group__group-core-concepts.html#ga8d8e06ab14ae860922eac58c1af30916">More...</a><br /></td></tr>
<tr class="separator:ga8d8e06ab14ae860922eac58c1af30916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f9c1ee21b2afd67ab72e733cbd5e9d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga82f9c1ee21b2afd67ab72e733cbd5e9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga82f9c1ee21b2afd67ab72e733cbd5e9d">ozo::HanaSequence</a></td></tr>
<tr class="memdesc:ga82f9c1ee21b2afd67ab72e733cbd5e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost.Hana Sequence concept.  <a href="group__group-core-concepts.html#ga82f9c1ee21b2afd67ab72e733cbd5e9d">More...</a><br /></td></tr>
<tr class="separator:ga82f9c1ee21b2afd67ab72e733cbd5e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ad173048912aca9e3a2be2d89ca328"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga64ad173048912aca9e3a2be2d89ca328"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga64ad173048912aca9e3a2be2d89ca328">ozo::HanaStruct</a></td></tr>
<tr class="memdesc:ga64ad173048912aca9e3a2be2d89ca328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost.Hana Structure concept.  <a href="group__group-core-concepts.html#ga64ad173048912aca9e3a2be2d89ca328">More...</a><br /></td></tr>
<tr class="separator:ga64ad173048912aca9e3a2be2d89ca328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7bc85faa1a6f71cf327510ca1b64d62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae7bc85faa1a6f71cf327510ca1b64d62"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#gae7bc85faa1a6f71cf327510ca1b64d62">ozo::HanaString</a></td></tr>
<tr class="memdesc:gae7bc85faa1a6f71cf327510ca1b64d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost.Hana String concept.  <a href="group__group-core-concepts.html#gae7bc85faa1a6f71cf327510ca1b64d62">More...</a><br /></td></tr>
<tr class="separator:gae7bc85faa1a6f71cf327510ca1b64d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb3476064c95a489c8c42d06d8434443"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafb3476064c95a489c8c42d06d8434443"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#gafb3476064c95a489c8c42d06d8434443">ozo::HanaTuple</a></td></tr>
<tr class="memdesc:gafb3476064c95a489c8c42d06d8434443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost.Hana Tuple concept.  <a href="group__group-core-concepts.html#gafb3476064c95a489c8c42d06d8434443">More...</a><br /></td></tr>
<tr class="separator:gafb3476064c95a489c8c42d06d8434443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3630bba60dd6977e70781ab0afe0cffd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3630bba60dd6977e70781ab0afe0cffd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga3630bba60dd6977e70781ab0afe0cffd">ozo::FusionAdaptedStruct</a></td></tr>
<tr class="memdesc:ga3630bba60dd6977e70781ab0afe0cffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost.Fusion Adapted Structure concept.  <a href="group__group-core-concepts.html#ga3630bba60dd6977e70781ab0afe0cffd">More...</a><br /></td></tr>
<tr class="separator:ga3630bba60dd6977e70781ab0afe0cffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad66641f2bf2a66458e7a79d5d71806b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad66641f2bf2a66458e7a79d5d71806b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#gad66641f2bf2a66458e7a79d5d71806b7">ozo::Integral</a></td></tr>
<tr class="memdesc:gad66641f2bf2a66458e7a79d5d71806b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral concept.  <a href="group__group-core-concepts.html#gad66641f2bf2a66458e7a79d5d71806b7">More...</a><br /></td></tr>
<tr class="separator:gad66641f2bf2a66458e7a79d5d71806b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351423cc3c81ca247a3c8ecea7beabb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga351423cc3c81ca247a3c8ecea7beabb2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga351423cc3c81ca247a3c8ecea7beabb2">ozo::FloatingPoint</a></td></tr>
<tr class="memdesc:ga351423cc3c81ca247a3c8ecea7beabb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating Point concept.  <a href="group__group-core-concepts.html#ga351423cc3c81ca247a3c8ecea7beabb2">More...</a><br /></td></tr>
<tr class="separator:ga351423cc3c81ca247a3c8ecea7beabb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d1faddb4ee1e9ff5d132885fc03713"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga21d1faddb4ee1e9ff5d132885fc03713"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga21d1faddb4ee1e9ff5d132885fc03713">ozo::RawDataWritable</a></td></tr>
<tr class="memdesc:ga21d1faddb4ee1e9ff5d132885fc03713"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>RawDataWritable</code> concept  <a href="group__group-core-concepts.html#ga21d1faddb4ee1e9ff5d132885fc03713">More...</a><br /></td></tr>
<tr class="separator:ga21d1faddb4ee1e9ff5d132885fc03713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ba61bc397781f71abf14ab436b16f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf2ba61bc397781f71abf14ab436b16f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#gaf2ba61bc397781f71abf14ab436b16f2">ozo::RawDataReadable</a></td></tr>
<tr class="memdesc:gaf2ba61bc397781f71abf14ab436b16f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>RawDataReadable</code> concept  <a href="group__group-core-concepts.html#gaf2ba61bc397781f71abf14ab436b16f2">More...</a><br /></td></tr>
<tr class="separator:gaf2ba61bc397781f71abf14ab436b16f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474575596a9253f3aad1f7ff5014425b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga474575596a9253f3aad1f7ff5014425b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga474575596a9253f3aad1f7ff5014425b">ozo::Emplaceable</a></td></tr>
<tr class="memdesc:ga474575596a9253f3aad1f7ff5014425b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaceable concept.  <a href="group__group-core-concepts.html#ga474575596a9253f3aad1f7ff5014425b">More...</a><br /></td></tr>
<tr class="separator:ga474575596a9253f3aad1f7ff5014425b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53bfbf36e6cf65fc04a27c77dd23f6de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga53bfbf36e6cf65fc04a27c77dd23f6de"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga53bfbf36e6cf65fc04a27c77dd23f6de">ozo::TimeConstraint</a> = is_time_constrain&lt;std::decay_t&lt;T&gt;&gt;::<a class="el" href="classozo_1_1value.html">value</a></td></tr>
<tr class="memdesc:ga53bfbf36e6cf65fc04a27c77dd23f6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time constrain concept.  <a href="group__group-core-concepts.html#ga53bfbf36e6cf65fc04a27c77dd23f6de">More...</a><br /></td></tr>
<tr class="separator:ga53bfbf36e6cf65fc04a27c77dd23f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6513d4477f12ddf822036eb03d7891fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6513d4477f12ddf822036eb03d7891fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga6513d4477f12ddf822036eb03d7891fa">ozo::CompletionToken</a></td></tr>
<tr class="memdesc:ga6513d4477f12ddf822036eb03d7891fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion token concept.  <a href="group__group-core-concepts.html#ga6513d4477f12ddf822036eb03d7891fa">More...</a><br /></td></tr>
<tr class="separator:ga6513d4477f12ddf822036eb03d7891fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf7889950bd13896cf94a61580635e8c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaaf7889950bd13896cf94a61580635e8c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#gaaf7889950bd13896cf94a61580635e8c">ozo::Handler</a></td></tr>
<tr class="memdesc:gaaf7889950bd13896cf94a61580635e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler concept.  <a href="group__group-core-concepts.html#gaaf7889950bd13896cf94a61580635e8c">More...</a><br /></td></tr>
<tr class="separator:gaaf7889950bd13896cf94a61580635e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb469295c856e5df036e640a55322b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5cb469295c856e5df036e640a55322b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga5cb469295c856e5df036e640a55322b1">ozo::Nullable</a></td></tr>
<tr class="memdesc:ga5cb469295c856e5df036e640a55322b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if type is marked as conformed to nullable requirements.  <a href="group__group-core-concepts.html#ga5cb469295c856e5df036e640a55322b1">More...</a><br /></td></tr>
<tr class="separator:ga5cb469295c856e5df036e640a55322b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5036d10d39ff20ad5c534ed7c4a696"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3b5036d10d39ff20ad5c534ed7c4a696"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core-concepts.html#ga3b5036d10d39ff20ad5c534ed7c4a696">ozo::HasDefinition</a></td></tr>
<tr class="memdesc:ga3b5036d10d39ff20ad5c534ed7c4a696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition indicates if type has corresponding type traits for PostgreSQL.  <a href="group__group-core-concepts.html#ga3b5036d10d39ff20ad5c534ed7c4a696">More...</a><br /></td></tr>
<tr class="separator:ga3b5036d10d39ff20ad5c534ed7c4a696"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Types</h2>
<a id="gaec336e235cdaabead728b12ecb63b38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec336e235cdaabead728b12ecb63b38a">&#9670;&nbsp;</a></span>Require</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Condition, typename Type  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__group-core-concepts.html#gaec336e235cdaabead728b12ecb63b38a">ozo::Require</a> = typedef Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept requirement emulation. </p>
<p>This is requirement simulation type, which is the alias to std::enable_if_t. It is pretty simple to use it with pseudo-concepts such as OperatorNot, Iterable and so on. E.g. overloading functions via Require: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">decltype(<span class="keyword">auto</span>) <a class="code" href="group__group-core-functions.html#ga7d5539cb3d5d8e4caf46e62aa5fe27aa">unwrap</a>(T&amp;&amp; c, <a class="code" href="group__group-core-concepts.html#gaec336e235cdaabead728b12ecb63b38a">Require</a>&lt;!<a class="code" href="group__group-core-concepts.html#ga5cb469295c856e5df036e640a55322b1">Nullable</a>&lt;T&gt;&gt;* = 0) {</div><div class="line">    <span class="keywordflow">return</span> c;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">decltype(<span class="keyword">auto</span>) <a class="code" href="group__group-core-functions.html#ga7d5539cb3d5d8e4caf46e62aa5fe27aa">unwrap</a>(T&amp;&amp; c, <a class="code" href="group__group-core-concepts.html#gaec336e235cdaabead728b12ecb63b38a">Require</a>&lt;<a class="code" href="group__group-core-concepts.html#ga5cb469295c856e5df036e640a55322b1">Nullable</a>&lt;T&gt;&gt;* = 0) {</div><div class="line">    <span class="keywordflow">return</span> *c;</div><div class="line">}</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Condition</td><td>- logical combination of concepts. </td></tr>
    <tr><td class="paramname">Type</td><td>- return type, <em>void</em> by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type if Condition is true </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga6513d4477f12ddf822036eb03d7891fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6513d4477f12ddf822036eb03d7891fa">&#9670;&nbsp;</a></span>CompletionToken</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::CompletionToken</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completion token concept. </p>
<p><code>CompletionToken</code> is an entity which determines how to continue with asynchronous operation result when the operation is complete. According to <a href="https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio/reference/async_completion.html"><code>boost::asio::async_completion</code></a> it defines the return value of an asynchronous function.</p>
<p>Assume we have an asynchronous IO function: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConnectionProv<span class="keywordtype">id</span>er, <span class="keyword">typename</span> CompletionToken&gt;</div><div class="line"><span class="keyword">auto</span> async_io(<a class="code" href="group__group-connection-concepts.html#ga81740a704092279e94bf9007ae3f722b">ConnectionProvider</a>&amp;&amp;, Param1 p1, ..., <a class="code" href="group__group-core-concepts.html#ga6513d4477f12ddf822036eb03d7891fa">CompletionToken</a>&amp;&amp;);</div></div><!-- fragment --><p>Then the result type of the function depends on <code>CompletionToken</code>, and <code>CompletionToken</code> - is any of these next entities:</p><ul>
<li><a class="el" href="group__group-core-concepts.html#gaaf7889950bd13896cf94a61580635e8c" title="Handler concept.">Handler</a> concept implementation. Asynchronous function in this case will return <code>void</code>. In this case the equivalent function signature will be: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConnectionProv<span class="keywordtype">id</span>er&gt;</div><div class="line"><span class="keywordtype">void</span> async_io(<a class="code" href="group__group-connection-concepts.html#ga81740a704092279e94bf9007ae3f722b">ConnectionProvider</a>, Param1 p1, ..., <a class="code" href="group__group-core-concepts.html#gaaf7889950bd13896cf94a61580635e8c">Handler</a>);</div></div><!-- fragment --></li>
<li><a href="https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio/reference/use_future.html"><code>boost::asio::use_future</code></a> - to get a future on the asynchronous operation result. Asynchronous function in this case will return <code>std::future&lt;Connection&gt;</code>. In this case the equivalent function signature will be: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConnectionProv<span class="keywordtype">id</span>er&gt;</div><div class="line">std::future&lt;ozo::connection_type&lt;ConnectionProvider&gt;&gt; async_io(</div><div class="line">    <a class="code" href="group__group-connection-concepts.html#ga81740a704092279e94bf9007ae3f722b">ConnectionProvider</a>&amp;&amp;, Param1 p1, ..., boost::asio::use_future_t);</div></div><!-- fragment --></li>
<li><a href="https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio/reference/basic_yield_context.html"><code>boost::asio::yield_context</code></a> - to use async operation with Boost.Coroutine. Asynchronous function in this case will return <a class="el" href="group__group-connection-concepts.html#ga9b549bf74e3c13c97f24493211722d9d" title="Database connection concept.">Connection</a>. In this case the equivalent function signature will be: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConnectionProv<span class="keywordtype">id</span>er&gt;</div><div class="line"><a class="code" href="group__group-connection-types.html#gabcdb5813817ad23b230ac6d9a924cf42">ozo::connection_type&lt;ConnectionProvider&gt;</a> async_io(</div><div class="line">    <a class="code" href="group__group-connection-concepts.html#ga81740a704092279e94bf9007ae3f722b">ConnectionProvider</a>&amp;&amp;, Param1 p1, ..., boost::asio::yield_context);</div></div><!-- fragment --></li>
<li>any other type supported with <a href="https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio/reference/async_completion.html"><code>boost::asio::async_completion</code></a> mechanism. Asynchronous function in this case will return a type is depends on <a href="https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio/reference/async_completion/result.html"><code>boost::asio::async_completion::result</code></a>. </li>
</ul>

</div>
</div>
<a id="ga474575596a9253f3aad1f7ff5014425b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga474575596a9253f3aad1f7ff5014425b">&#9670;&nbsp;</a></span>Emplaceable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::Emplaceable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emplaceable concept. </p>
<p>Indicates if container T can emplace it's element with default constructor </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga351423cc3c81ca247a3c8ecea7beabb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga351423cc3c81ca247a3c8ecea7beabb2">&#9670;&nbsp;</a></span>FloatingPoint</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::FloatingPoint</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Floating Point concept. </p>
<p>Indicates if T is a floating point type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga762b9c7d7a45486c590d33ddb1330e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762b9c7d7a45486c590d33ddb1330e9e">&#9670;&nbsp;</a></span>ForwardIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::ForwardIterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward Iterator concept. </p>
<p>Returns true if T meets forward_iterator conditions </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3630bba60dd6977e70781ab0afe0cffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3630bba60dd6977e70781ab0afe0cffd">&#9670;&nbsp;</a></span>FusionAdaptedStruct</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::FusionAdaptedStruct</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boost.Fusion Adapted Structure concept. </p>
<p>Indicates it T is a Boost.Fusion adapted structure via BOOST_FUSION_ADAPT_STRUCT or similar. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d8e06ab14ae860922eac58c1af30916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d8e06ab14ae860922eac58c1af30916">&#9670;&nbsp;</a></span>FusionSequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::FusionSequence</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boost.Fusion Sequence concept. </p>
<p>Indicates if T is a Boost.Fusion Sequence type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82f9c1ee21b2afd67ab72e733cbd5e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82f9c1ee21b2afd67ab72e733cbd5e9d">&#9670;&nbsp;</a></span>HanaSequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::HanaSequence</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boost.Hana Sequence concept. </p>
<p>Indicates if T is a Boost.Hana Sequence type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7bc85faa1a6f71cf327510ca1b64d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7bc85faa1a6f71cf327510ca1b64d62">&#9670;&nbsp;</a></span>HanaString</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::HanaString</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boost.Hana String concept. </p>
<p>Indicates if T is a Boost.Hana String type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64ad173048912aca9e3a2be2d89ca328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64ad173048912aca9e3a2be2d89ca328">&#9670;&nbsp;</a></span>HanaStruct</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::HanaStruct</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boost.Hana Structure concept. </p>
<p>Indicates if T is a Boost.Hana Structure type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb3476064c95a489c8c42d06d8434443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb3476064c95a489c8c42d06d8434443">&#9670;&nbsp;</a></span>HanaTuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::HanaTuple</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boost.Hana Tuple concept. </p>
<p>Indicates if T is a Boost.Hana Tuple type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf7889950bd13896cf94a61580635e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf7889950bd13896cf94a61580635e8c">&#9670;&nbsp;</a></span>Handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::Handler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler concept. </p>
<p><code>Handler</code> is a function or a functor which is used as a callback for handling result of asynchronous IO operations in the library.</p>
<p>In case of function it has to have this signature: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Connection&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__group-core-concepts.html#gaaf7889950bd13896cf94a61580635e8c">Handler</a>(<a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec, <a class="code" href="group__group-connection-concepts.html#ga9b549bf74e3c13c97f24493211722d9d">Connection</a> connection) {</div><div class="line">    <span class="comment">//...</span></div><div class="line">}</div></div><!-- fragment --><p>In case of functor it has to have such <code>operator()</code>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="group__group-core-concepts.html#gaaf7889950bd13896cf94a61580635e8c">Handler</a> {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Connection&gt;</div><div class="line">    <span class="keywordtype">void</span> operator() (<a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec, <a class="code" href="group__group-connection-concepts.html#ga9b549bf74e3c13c97f24493211722d9d">Connection</a> connection) {</div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>In case of lambda: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="group__group-core-concepts.html#gaaf7889950bd13896cf94a61580635e8c">Handler</a> = [&amp;] (<a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec, <span class="keyword">auto</span> connection) {</div><div class="line">    <span class="comment">//...</span></div><div class="line">};</div></div><!-- fragment --><p><code>Handler</code> has to handle an <code><a class="el" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731" title="Error code representation of the library.">ozo::error_code</a></code> object as first argument, and <a class="el" href="group__group-connection-concepts.html#ga9b549bf74e3c13c97f24493211722d9d" title="Database connection concept.">Connection</a> implementation object as a second one. It is better to define second argument as a template parameter because the implementation depends on a numerous of compile-time options but if it is really needed - real type can be obtained with <code><a class="el" href="group__group-connection-types.html#gabcdb5813817ad23b230ac6d9a924cf42" title="Gives exact type of a connection object which ConnectionProvider or ConnectionSource provide.">ozo::connection_type</a></code>.</p>
<p><code>Handler</code> has to be invoked according to this rules:</p><ul>
<li><b>Operation succeeded</b> &mdash; <code><a class="el" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731" title="Error code representation of the library.">ozo::error_code</a></code> is empty, <a class="el" href="group__group-connection-concepts.html#ga9b549bf74e3c13c97f24493211722d9d" title="Database connection concept.">Connection</a> is in good state and can be used for next IO.</li>
<li><b>Operation failed</b> &mdash; <code><a class="el" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731" title="Error code representation of the library.">ozo::error_code</a></code> contains error, <a class="el" href="group__group-connection-concepts.html#ga9b549bf74e3c13c97f24493211722d9d" title="Database connection concept.">Connection</a> can be in these states:<ul>
<li><a class="el" href="group__group-connection-concepts.html#ga9b549bf74e3c13c97f24493211722d9d" title="Database connection concept.">Connection</a> in null-state &mdash; <code><a class="el" href="group__group-core-functions.html#ga60f6f6924a9f600f1c2c6dcff2316d06" title="Indicates if value is in null state.">ozo::is_null()</a></code> returns <code>true</code>, object is useless;</li>
<li><a class="el" href="group__group-connection-concepts.html#ga9b549bf74e3c13c97f24493211722d9d" title="Database connection concept.">Connection</a> in bad state &mdash; <code><a class="el" href="group__group-core-functions.html#ga60f6f6924a9f600f1c2c6dcff2316d06" title="Indicates if value is in null state.">ozo::is_null()</a></code> returns <code>false</code>, object may provide additional error context via <code><a class="el" href="group__group-connection-functions.html#gae1d570854c32a38adcad99baf73e0baa" title="Gives native libpq error message.">ozo::error_message()</a></code> and <code><a class="el" href="group__group-connection-functions.html#ga3b48ff27d7b2258c853a422382ef8e6a" title="Additional error context getter.">ozo::get_error_context()</a></code> functions. </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga3b5036d10d39ff20ad5c534ed7c4a696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b5036d10d39ff20ad5c534ed7c4a696">&#9670;&nbsp;</a></span>HasDefinition</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::HasDefinition</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Condition indicates if type has corresponding type traits for PostgreSQL. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>&mdash; type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4bca84123276a5399ea63f2e249bd04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bca84123276a5399ea63f2e249bd04d">&#9670;&nbsp;</a></span>InsertIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::InsertIterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert Iterator concept. </p>
<p>This trait determines whether T is an insert iterator bound with some container </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad66641f2bf2a66458e7a79d5d71806b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad66641f2bf2a66458e7a79d5d71806b7">&#9670;&nbsp;</a></span>Integral</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::Integral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integral concept. </p>
<p>Indicates if T is an integral type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf513c2ac32e89e730a1019c94ec8fb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf513c2ac32e89e730a1019c94ec8fb19">&#9670;&nbsp;</a></span>Iterable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::Iterable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterable concept. </p>
<p>Determines whether T can be iterated through via begin() end() functions </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cb469295c856e5df036e640a55322b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb469295c856e5df036e640a55322b1">&#9670;&nbsp;</a></span>Nullable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::Nullable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if type is marked as conformed to nullable requirements. </p>
<p>These next types are defined as <code>Nullable</code> via <a class="el" href="group__group-ext.html">Extentions</a> of the library:</p><ul>
<li><a class="el" href="group__group-ext-boost-optional.html">boost::optional</a>,</li>
<li><a class="el" href="group__group-ext-boost-scoped__ptr.html">boost::scoped_ptr</a>,</li>
<li><a class="el" href="group__group-ext-boost-shared__ptr.html">boost::shared_ptr</a>,</li>
<li><a class="el" href="group__group-ext-boost-weak__ptr.html">boost::weak_ptr</a>,</li>
<li><a class="el" href="group__group-ext-std-nullopt.html">std::nullopt_t</a>,</li>
<li><a class="el" href="group__group-ext-std-nullptr.html">std::nullptr</a>,</li>
<li><a class="el" href="group__group-ext-std-optional.html">std::optional</a>,</li>
<li><a class="el" href="group__group-ext-std-shared__ptr.html">std::shared_ptr</a>,</li>
<li><a class="el" href="group__group-ext-std-unique__ptr.html">std::unique_ptr</a>,</li>
<li><a class="el" href="group__group-ext-std-weak__ptr.html">std::weak_ptr</a>.</li>
</ul>
<p>If it is needed to mark type as nullable then <code>ozo::is_nullable</code> from the type should be specialized as <code>std::true_type</code> type. If the type has to be allocated in special way &mdash; <code><a class="el" href="group__group-core-functions.html#gacdbea0d12bdc6a1279c010659190a1a3" title="Allocates nullable object of given type.">ozo::allocate_nullable()</a></code> should be specialized (see <a class="el" href="group__group-ext-std-shared__ptr.html">std::shared_ptr</a> as an example).</p>
<h3>Example</h3>
<p>Raw pointers are not supported as <code>Nullable</code> by default, because this library uses RAII model for objects and no special deallocation functions are used. But if it is really needed and you want to deallocate the allocated objects manually you can add them as described below.</p>
<div class="fragment"><div class="line"><span class="comment">//Add raw pointer to nullables</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceozo.html">ozo</a> {</div><div class="line"></div><div class="line"><span class="comment">// Mark raw pointer as nullable</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>is_nullable&lt;T*&gt; : std::true_type {};</div><div class="line"></div><div class="line"><span class="comment">// Specify allocation function</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>allocate_nullable_impl&lt;T*&gt; {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Alloc&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> apply(T*&amp; out, <span class="keyword">const</span> Alloc&amp;) {</div><div class="line">        out = <span class="keyword">new</span> T();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group-core-functions.html#ga60f6f6924a9f600f1c2c6dcff2316d06" title="Indicates if value is in null state.">is_null()</a>, <a class="el" href="group__group-core-functions.html#gacdbea0d12bdc6a1279c010659190a1a3" title="Allocates nullable object of given type.">allocate_nullable()</a>, init_nullable(), reset_nullable() </dd></dl>

</div>
</div>
<a id="gae0a9bc14ebe454c9d0b8f3055839d675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a9bc14ebe454c9d0b8f3055839d675">&#9670;&nbsp;</a></span>OperatorNot</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::OperatorNot</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator Not concept. </p>
<p>Return true if T has operator !(), false in other case </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3750f4893911580a5546d11bd5a9ca32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3750f4893911580a5546d11bd5a9ca32">&#9670;&nbsp;</a></span>OutputIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::OutputIterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output Iterator concept. </p>
<p>Returns true if T is output iterator </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2ba61bc397781f71abf14ab436b16f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ba61bc397781f71abf14ab436b16f2">&#9670;&nbsp;</a></span>RawDataReadable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::RawDataReadable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>RawDataReadable</code> concept </p>
<p>Indicates if <code>T</code> can be read as a sequence of bytes without endian conversion. <code>RawDataReadable&lt;T&gt;</code> is <code>true</code> if for object <code>v</code> of type <code>T</code> applicable one of this code: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> raw = v.data(std::as_const(v)); <span class="comment">// has_const_data&lt;T,</span></div><div class="line"><span class="keyword">auto</span> v = *raw;                       <span class="comment">//</span></div><div class="line">static_assert(<span class="keyword">sizeof</span>(v) == 1);       <span class="comment">//                1&gt;</span></div><div class="line"><span class="keyword">auto</span> n = v.size();                   <span class="comment">// has_size&lt;T&gt;</span></div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="keyword">auto</span> raw = data(std::as_const(v));   <span class="comment">// has_friend_const_data&lt;T,</span></div><div class="line"><span class="keyword">auto</span> v = *raw;                       <span class="comment">//</span></div><div class="line">static_assert(<span class="keyword">sizeof</span>(v) == 1);       <span class="comment">//                       1&gt;</span></div><div class="line"><span class="keyword">auto</span> n = size(v);                    <span class="comment">// has_friend_size&lt;T&gt;</span></div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21d1faddb4ee1e9ff5d132885fc03713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21d1faddb4ee1e9ff5d132885fc03713">&#9670;&nbsp;</a></span>RawDataWritable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::RawDataWritable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>RawDataWritable</code> concept </p>
<p>Indicates if <code>T</code> can be written as a sequence of bytes without endian conversion. <code>RawDataWritable&lt;T&gt;</code> is <code>true</code> if for object <code>v</code> of type <code>T</code> applicable one of this code: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> raw = v.data();              <span class="comment">// has_mutable_data&lt;T,</span></div><div class="line">*raw = 1;                         <span class="comment">//</span></div><div class="line">static_assert(<span class="keyword">sizeof</span>(*raw) == 1); <span class="comment">//                  1&gt;</span></div><div class="line"><span class="keyword">auto</span> n = v.size();                <span class="comment">// has_size&lt;T&gt;</span></div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="keyword">auto</span> raw = data(v);               <span class="comment">// has_friend_mutable_data&lt;T,</span></div><div class="line">*raw = 1;                         <span class="comment">//</span></div><div class="line">static_assert(<span class="keyword">sizeof</span>(*raw) == 1); <span class="comment">//                         1&gt;</span></div><div class="line"><span class="keyword">auto</span> n = size(v);                 <span class="comment">// has_friend_size&lt;T&gt;</span></div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type to examine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53bfbf36e6cf65fc04a27c77dd23f6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53bfbf36e6cf65fc04a27c77dd23f6de">&#9670;&nbsp;</a></span>TimeConstraint</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ozo::TimeConstraint = is_time_constrain&lt;std::decay_t&lt;T&gt;&gt;::<a class="el" href="classozo_1_1value.html">value</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time constrain concept. </p>
<p><code>TimeConstraint</code> is a type which provides information about time restrictions for an operation. Currently supported constrains:</p><ul>
<li><code>std::chrono::duration</code> &mdash; operation time-out duration,</li>
<li><code>std::chrono::time_point</code> &mdash; operation deadline time point,</li>
<li><code><a class="el" href="group__group-core-types.html#ga5dedeecb1a2753e4569e16a69b048608" title="None objectInstance of ozo::none_t type.">ozo::none</a></code> &mdash; operation is not restricted in time. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
