<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OZO 「お象」: How to</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OZO 「お象」
   </div>
   <div id="projectbrief">Boost.Asio and libpq based asynchronous PostgreSQL unofficial header-only C++17 client library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_howto.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">How to </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Here are some examples of how to use OZO API.</p>
<ul>
<li><a href="#how-to">How to</a><ul>
<li><a href="#how-to-make-a-very-simple-request">How To Make A Very Simple request</a></li>
<li><a href="#how-to-handle-error-properly">How To Handle Error Properly</a></li>
<li><a href="#how-start-to-do-not-bother-with-types-sequence-in-row-but-begin-to-bother-about-column-names">How Start To Do Not Bother With Types Sequence In Row But Begin To Bother About Column Names</a></li>
<li><a href="#how-to-determine-which-type-do-i-need-to-use-for-the-postgresql-type">How To Determine Which Type Do I Need To Use For The PostgreSQL Type</a></li>
<li><a href="#how-to-bind-one-more-postgresql-type-for-c-type-with-existing-binding">How To Bind One More PostgreSQL Type For C++ Type With Existing Binding</a></li>
</ul>
</li>
</ul>
<h2>How To Make A Very Simple request</h2>
<p>E.g. you have <em>very</em> simple table.</p>
<div class="fragment"><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users_info(</div><div class="line">    id          <span class="keywordtype">bigint</span>  <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div><div class="line">    name        text,</div><div class="line">    amount      <span class="keywordtype">bigint</span>  <span class="keyword">NOT</span> <span class="stringliteral">NULL</span></div><div class="line">);</div></div><!-- fragment --><p>If you want to execute a query with no custom types or something else then the simplest way for you is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ozo/request.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ozo/connection_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ozo/shortcuts.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/asio.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// We need io_context for IO</span></div><div class="line">    boost::asio::io_context io;</div><div class="line"></div><div class="line">    <span class="comment">// Container of rows which accepts integer and nullable string columns in the sequence.</span></div><div class="line">    <span class="comment">// (This is an alias on std::vector of std::tuple - see the documentation)</span></div><div class="line">    <a class="code" href="group__group-requests-types.html#gade9a42efa5064524382c2673de242f39">ozo::rows_of&lt;std::int64_t, std::optional&lt;std::string&gt;</a>&gt; rows;</div><div class="line"></div><div class="line">    <span class="comment">// Connection info with host and port to connect to</span></div><div class="line">    <span class="keyword">auto</span> conn_info = ozo::make_connection_info(<span class="stringliteral">&quot;host=... port=...&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// For _SQL literal</span></div><div class="line">    <span class="keyword">using namespace </span>ozo::literals;</div><div class="line">    <span class="comment">// Our query statement</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> query = <span class="stringliteral">&quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;</span>_SQL + std::int64_t(25);</div><div class="line"></div><div class="line">    <span class="comment">// Request with connection provider, query and callback.</span></div><div class="line">    <a class="code" href="group__group-requests-functions.html#ga00b600b78684dcd4141d83664cd7bc93">ozo::request</a>(ozo::make_connector(conn_info, io), query, <a class="code" href="group__group-requests-functions.html#ga3e8f5ef58a370e79b7e554cd09fbc705">ozo::into</a>(rows),</div><div class="line">            [&amp;](<a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec, <span class="keyword">auto</span> conn) {</div><div class="line">        <span class="comment">// Here we got an error, so we can get:</span></div><div class="line">        <span class="keywordflow">if</span> (ec) {</div><div class="line">            <span class="comment">// * Print error code&#39;s message</span></div><div class="line">            std::cerr &lt;&lt; ec.message();</div><div class="line">            <span class="comment">// * Print error message from underlying libpq</span></div><div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot; | &quot;</span> &lt;&lt; <a class="code" href="group__group-connection-functions.html#gae1d570854c32a38adcad99baf73e0baa">ozo::error_message</a>(conn);</div><div class="line">            <span class="comment">// * Print additional error context from OZO</span></div><div class="line">            <span class="keywordflow">if</span> (!<a class="code" href="group__group-core-functions.html#ga602abbe1728381084559b85c3835b9bb">ozo::is_null_recursive</a>(conn)) {</div><div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot; | &quot;</span> &lt;&lt; <a class="code" href="group__group-connection-functions.html#ga3b48ff27d7b2258c853a422382ef8e6a">ozo::get_error_context</a>(conn);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="comment">// Connection should be in good state here,</span></div><div class="line">        <span class="comment">// typically you do not need to check it manually</span></div><div class="line">        assert(<a class="code" href="group__group-connection-functions.html#gad408c2b5b86f7246963a84a8ceae29af">ozo::connection_good</a>(conn));</div><div class="line"></div><div class="line">        <span class="comment">// We got results, let&#39;s handle, e.g. print it out</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;id&quot;</span> &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; <span class="stringliteral">&quot;name&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; row: res) {</div><div class="line">            std::cout &lt;&lt; std::get&lt;0&gt;(row) &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; std::get&lt;1&gt;(row) &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    });</div><div class="line"></div><div class="line">    io.run();</div><div class="line">}</div></div><!-- fragment --><p>Let's look a little bit closer on this pretty simple but asynchronous code.</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-requests-types.html#gade9a42efa5064524382c2673de242f39">ozo::rows_of&lt;std::int64_t, std::optional&lt;std::string&gt;</a>&gt; rows;</div></div><!-- fragment --><p>Here we define a result type. Practically <code><a class="el" href="group__group-requests-types.html#gade9a42efa5064524382c2673de242f39" title="Shortcut for easy result container definition.">ozo::rows_of</a></code> is an alias on <code>std::vector&lt;std::tuple&lt;...&gt;&gt;</code>. And <code><a class="el" href="group__group-requests-functions.html#ga3e8f5ef58a370e79b7e554cd09fbc705" title="Shortcut for create result container back inserter.">ozo::into</a></code> is an alias on <code>std::back_inserter</code>. So <code><a class="el" href="group__group-requests-functions.html#ga00b600b78684dcd4141d83664cd7bc93" title="Request query from a database.">ozo::request()</a></code> function will fill this vector of tuples according to the database response rows. Please read the documentation for more details.</p>
<p>It is <em>very important</em> to preserve the same order of fields in request and types in the tuple (it is a little bit annoying, but there is a way to avoid it via <a href="https://www.boost.org/doc/libs/1_66_0/libs/hana/doc/html/index.html#tutorial-introspection-adapting">Boost.Hana</a> or <a href="https://www.boost.org/doc/libs/1_66_0/libs/fusion/doc/html/fusion/adapted.html">Boost.Fusion</a> structure adaptation).</p>
<p>There is <code>std::optional&lt;std::string&gt;</code> at the second position of the tuple. This is because <code>name</code> field of the table can be <em>NULL</em>. Empty optional represents the <em>NULL</em> (you can learn more about Nullable concept from the documentation). If you omit an <code>std::optional</code> then in case of <em>NULL</em> value deserialization error could be.</p>
<p>The first argument of the tuple can not be a <em>NULL</em> due to the schema, so we can omit <code>std::optional</code>.</p>
<p>In other words: there is no mistake to expect nullable type for non-nullable result, but the opposite leads to a run-time error in case of <em>NULL</em> value received from a database.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> conn_info = ozo::make_connection_info(<span class="stringliteral">&quot;host=... port=...&quot;</span>);</div></div><!-- fragment --><p>Now we need to create a connection information for database to connect to. This is our connection source which can create a connection for us as it will be needed (you can learn more about ConnectionSource and ConnectionProvider concepts from the documentation).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> query = <span class="stringliteral">&quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;</span>_SQL + std::int64_t(25);</div></div><!-- fragment --><p>Here our query for database. There is a text with <code>_SQL</code> literal and a parameter <code>std::int64_t(25)</code>. Note that the parameter will be passed as a separate binary parameter, but not as part of the query text.</p>
<p>Here is <code><a class="el" href="group__group-requests-functions.html#ga00b600b78684dcd4141d83664cd7bc93" title="Request query from a database.">request()</a></code> asynchronous function call.</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-requests-functions.html#ga00b600b78684dcd4141d83664cd7bc93">ozo::request</a>(ozo::make_connector(conn_info, io), query, <a class="code" href="group__group-requests-functions.html#ga3e8f5ef58a370e79b7e554cd09fbc705">ozo::into</a>(res),</div><div class="line">        [&amp;](<a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec, <span class="keyword">auto</span> conn) {</div><div class="line"><span class="comment">//...</span></div><div class="line">});</div></div><!-- fragment --><p><code>ozo::make_connector(conn_info, io)</code> - the first parameter is a <b>ConnectionProvider</b> or a <b>Connection</b>. <b>ConnectionProvider</b> is an entity from which you can get a new (or may be already established) connection. <b>Connection</b> is a <b>ConnectionProvider</b> since it can provide itself. So the query request will be performed within connection obtained for the first argument.</p>
<p><code>query</code> - the next argument is query which we discussed above.</p>
<p><code>ozo::into(res)</code> - the output parameter. In this case the out parameter is a back insert iterator to the result vector. Note, that the life time of the output parameter should be managed by a user. In this example it correctly placed on stack since its lifetime overlaps <code>io.run()</code> call. The query output parameter can be iterator with appropriated value type, or <code>ozo::result</code> object which provides access to raw binary data. The second variant is not recommended since user should implement binary protocol parsing by self.</p>
<p><code>[&amp;](<a class="el" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731" title="Error code representation of the library.">ozo::error_code</a> ec, auto conn)</code> - completion token parameter, in this case is callback lambda. In other cases it can be <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/use_future.html">boost::asio::use_future</a>, <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/yield_context.html">boost::asio::yield_context</a> or any other <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/async_result.html">boost::asio::async_result</a> compatible <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/async_completion.html">Completion Token</a>. The arguments of the call back are error code <code>ec</code> (which is namely <code>boost::system::error_code</code> for now) and the connection <code>conn</code> with which the query was made.</p>
<p><code>for(auto&amp; row: res)</code> - so if there is no error we can handle result from the output container.</p>
<hr/>
<h2>How To Handle Error Properly</h2>
<p>OZO uses <code>boost::system::error_code</code> to indicate an error and therefore, like <code>std::error_code</code>, it cannot provide any context-dependent information at all. So unfortunately <code>error_code::message()</code> returns only a static textual description of the code. But this is not enough, especially for sql errors. That's why the additional error information is needed and can be obtained via these two functions:</p>
<ul>
<li><code><a class="el" href="group__group-connection-functions.html#gae1d570854c32a38adcad99baf73e0baa" title="Gives native libpq error message.">ozo::error_message()</a></code> - provides a <code>std::string_view</code> with native error message from libpq,</li>
<li><code><a class="el" href="group__group-connection-functions.html#ga3b48ff27d7b2258c853a422382ef8e6a" title="Additional error context getter.">ozo::get_error_context()</a></code> - provides an additional error context from OZO.</li>
</ul>
<p>Please learn more about these function in the documentation.</p>
<p><b>Example</b>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_error (std::ostream&amp; s, <a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec) {</div><div class="line">    s &lt;&lt; <span class="stringliteral">&quot;Request failed with error: &quot;</span> &lt;&lt; ec.message();</div><div class="line">    <span class="comment">// Here we should check if the connection is in null state to avoid UB.</span></div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="group__group-core-functions.html#ga602abbe1728381084559b85c3835b9bb">ozo::is_null_recursive</a>(connection)) {</div><div class="line">        <span class="comment">// Let&#39;s check libpq native error message and if so - print it out</span></div><div class="line">        <span class="keywordflow">if</span> (<span class="keyword">auto</span> msg = <a class="code" href="group__group-connection-functions.html#gae1d570854c32a38adcad99baf73e0baa">ozo::error_message</a>(connection); !msg.empty()) {</div><div class="line">            s &lt;&lt; <span class="stringliteral">&quot;, error message: &quot;</span> &lt;&lt; msg;</div><div class="line">        }</div><div class="line">        <span class="comment">// Sometimes libpq native error message is not enough, so let&#39;s check</span></div><div class="line">        <span class="comment">// the additional error context from OZO</span></div><div class="line">        <span class="keywordflow">if</span> (<span class="keyword">auto</span> ctx = <a class="code" href="group__group-connection-functions.html#ga3b48ff27d7b2258c853a422382ef8e6a">ozo::get_error_context</a>(connection); !ctx.empty()) {</div><div class="line">            s &lt;&lt; <span class="stringliteral">&quot;, additional error context: &quot;</span> &lt;&lt; ctx;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><hr/>
<h2>How Start To Do Not Bother With Types Sequence In Row But Begin To Bother About Column Names</h2>
<p>In previous story we saw how to do a simple request. But there is a tricky thing with sequence of types in result: </p><div class="fragment"><div class="line"><a class="code" href="group__group-requests-types.html#gade9a42efa5064524382c2673de242f39">ozo::rows_of&lt;std::int64_t, std::optional&lt;std::string&gt;</a>&gt; rows;</div><div class="line"></div><div class="line"><span class="comment">//...</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> query = <span class="stringliteral">&quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;</span>_SQL + std::int64_t(25);</div></div><!-- fragment --><p>If we interchange <code>id</code> and <code>name</code> in the query text we will get a run-time error. To be more robust for such changes there is another way - adaptation. E.g. with Boost.Fusion.</p>
<div class="fragment"><div class="line">BOOST_FUSION_DEFINE_STRUCT((), my_row,</div><div class="line">    (std::int64_t, <span class="keywordtype">id</span>)</div><div class="line">    (std::optional&lt;std::string&gt;, name)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line"><span class="comment">//...</span></div><div class="line"></div><div class="line">    std::vector&lt;my_row&gt; res;</div><div class="line"></div><div class="line"><span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> query = <span class="stringliteral">&quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;</span>_SQL + std::int64_t(25);</div><div class="line"></div><div class="line">    <a class="code" href="group__group-requests-functions.html#ga00b600b78684dcd4141d83664cd7bc93">ozo::request</a>(ozo::make_connector(io, conn_info), query, <a class="code" href="group__group-requests-functions.html#ga3e8f5ef58a370e79b7e554cd09fbc705">ozo::into</a>(res),</div><div class="line">            [&amp;](<a class="code" href="group__group-errors.html#ga8757df037905ea8c9b69073e350dd731">ozo::error_code</a> ec, <span class="keyword">auto</span> conn) {</div><div class="line">    <span class="comment">//...</span></div><div class="line">    });</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>In this case you can change fields' places free. Fields and structure members are bound with their names.</p>
<hr/>
<h2>How To Determine Which Type Do I Need To Use For The PostgreSQL Type</h2>
<p>It is a good question! Since we are using binary protocol and have serialization/deserialization system we also have a type system. It is easy and extandable. For build-in types you can look at <a href="../include/ozo/type_traits.h">ozo/type_traits.h</a> for difinitions like:</p>
<div class="fragment"><div class="line">OZO_PG_DEFINE_TYPE(std::vector&lt;char&gt;, <span class="stringliteral">&quot;bytea&quot;</span>, BYTEAOID, dynamic_size)</div><div class="line"></div><div class="line"><a class="code" href="group__group-type__system-mapping.html#ga37e74e6593b00ce3dfda1213bf4b5724">OZO_PG_DEFINE_TYPE_AND_ARRAY</a>(boost::uuids::uuid, <span class="stringliteral">&quot;uuid&quot;</span>, UUIDOID, 2951, bytes&lt;16&gt;)</div></div><!-- fragment --><p><code>OZO_PG_DEFINE_TYPE(CPP_TYPE, PG_TYPE, OID, SIZE)</code> defines a C++ to built-in PostgreSQL type mapping. It's arguments are:</p>
<ul>
<li><code>CPP_TYPE</code> - C++ type.</li>
<li><code>PG_TYPE</code> - PostgreSQL type name.</li>
<li><code>OID</code> - type OID in PostgreSQL.</li>
<li><code>SIZE</code> - type size which can be static for N bytes <code>bytes(N)</code>, or dynamic <code>dynamic_size</code>, like in this case.</li>
</ul>
<p><code><a class="el" href="group__group-type__system-mapping.html#ga37e74e6593b00ce3dfda1213bf4b5724" title="Helper macro to define type mappingIn general type mapping is provided via ozo::definitions::type and...">OZO_PG_DEFINE_TYPE_AND_ARRAY(CPP_TYPE, PG_TYPE, OID, ARRAY_OID SIZE)</a></code> defines C++ to built-in PostgreSQL type mapping with it's array. The current array represantation in OZO is std::vector, so for <code>uuid</code> type it will be <code>std::vector&lt;uuid&gt;</code>.</p>
<p>Since the mapping is <em><b>C++** to **PostgreSQL</b></em>, you can extend it with your own types.</p>
<p>E.g. we have a <code>text</code> type definition like:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-type__system-mapping.html#ga37e74e6593b00ce3dfda1213bf4b5724">OZO_PG_DEFINE_TYPE_AND_ARRAY</a>(std::string, <span class="stringliteral">&quot;text&quot;</span>, TEXTOID, TEXTARRAYOID, dynamic_size)</div></div><!-- fragment --><p>You have your own brilliant string representation <code>Stroka</code> compatible with <code>const char* data(const Stroka&amp;)</code> and <code>const char* size(const Stroka&amp;)</code> functions (it is needed to use default introspection mechanisms). It can be included in type system and used as <code>text</code> representation like this:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-type__system-mapping.html#ga37e74e6593b00ce3dfda1213bf4b5724">OZO_PG_DEFINE_TYPE_AND_ARRAY</a>(Stroka, <span class="stringliteral">&quot;text&quot;</span>, TEXTOID, TEXTARRAYOID, dynamic_size)</div></div><!-- fragment --><p>Now you can get <code>text</code> into <code>Stroka</code> type, and put <code>Stroka</code> object like text in queries.</p>
<hr/>
<h2>How To Bind One More PostgreSQL Type For C++ Type With Existing Binding</h2>
<p>This is very common problem. A lot of PostgreSQL types can be represented via the same C++ types. E.g. <code>text</code>, <code>name</code>, <code>varchar</code> can be easily and convenient represented via <code>std::string</code>. But it can not be done, due to relation "one to many" between PostgreSQL type and C++ types. You can map <code>text</code> to several C++ types but you can not map several PostgreSQL types to a single C++ type. There is a solution for the problem in the library - <code>OZO_STRONG_TYPEDEF</code>. This macro allows you to define an alias on a type with strong type definition guarantee.</p>
<p>E.g. alias and definition for <code>bytea</code> type may looks like this:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-core-types.html#ga61078d1ef7bd8132469c8f5b627376b2">OZO_STRONG_TYPEDEF</a>(std::string, bytea)</div><div class="line"><span class="comment">//...</span></div><div class="line"><a class="code" href="group__group-type__system-mapping.html#ga37e74e6593b00ce3dfda1213bf4b5724">OZO_PG_DEFINE_TYPE_AND_ARRAY</a>(bytea, <span class="stringliteral">&quot;bytea&quot;</span>, BYTEAOID, 1001, dynamic_size)</div></div><!-- fragment --><p>You can access for the underlying type via conversion operator or <code>get()</code> method:</p>
<div class="fragment"><div class="line">bytea wrapped_value;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> n = static_cast&lt;const std::string&amp;&gt;(wrapped_value).find(<span class="charliteral">&#39; &#39;</span>);</div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="keyword">auto</span> n = wrapped_value.get().find(<span class="charliteral">&#39; &#39;</span>);</div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="keywordtype">bool</span> is_good_string(<span class="keyword">const</span> std::string&amp; v);</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="keywordtype">bool</span> flag = is_good_string(wrapped_value);</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
